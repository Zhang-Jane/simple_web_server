## 当服务器进程休眠60秒时，您仍然可以使用第二个curl命令连接到服务器？
当然，curl没有立即输出任何内容，它只是挂在那里，但为什么服务器当时不接受连接，客户端没有立即被拒绝，而是能够连接到服务器？
答案是套接字对象的侦听方法及其BACKLOG参数，我在代码中调用了REQUEST_QUEUE_SIZE。BACKLOG参数确定内核中传入连接请求的队列大小。当服务器webserver3b.py处于休眠状态时，您运行的第二个curl命令能够连接到服务器，因为内核在服务器套接字的传入连接请求队列中有足够的可用空间。
虽然增加BACKLOG参数并不能神奇地将您的服务器变为一次可以处理多个客户端请求的服务器，对于繁忙的服务器，有一个相当大的backlog参数是很重要的，这样accept调用就不必等待建立新的连接，而是可以立即从队列中获取新的连接并立即开始处理客户端请求。

## PID和PPID
在Linux中，存储在磁盘上的可执行文件称为程序加载到内存中并运行的过程称为进程。当一个进程启动时，它被赋予一个称为进程ID（PID）的唯一编号，用于标识
将该过程发送到系统。例如，如果您需要终止进程，您可以通过其PID来引用它。由于每个PID都是唯一的，因此没有模糊性或意外终止错误流程的风险（除非您输入错误的PID）。
如果打开top（在终端中，键入top并按enter键），PID列列出当前加载到内存中的所有进程的进程ID
无论状态如何（休眠、僵尸等）。两个守护程序（系统进程）和用户进程（您自动启动的进程或手动）具有自己的进程ID。PID并不总是以数字顺序分配，因此很正常地看到数字的随机选择

除了唯一的进程ID外，还为每个进程分配了一个父进程进程ID（PPID），指示哪个进程启动了它。PPID是进程的父级。例如，如果PID为101的进程1启动名为process2，则process2将被赋予一个唯一的PID，例如3240，但它将获得101的PPID。这是一种亲子关系。一张单曲父进程可以派生多个子进程，每个子进程都具有唯一的PID，但都共享相同的PPID。

![](https://delightlylinux.files.wordpress.com/2012/06/pid.png)

## 如何编写并发服务器

尝试之前在迭代服务器上尝试过的两个curl命令，现在，即使服务器子进程在服务客户端请求后休眠60秒，也不会影响其他客户端，因为它们由不同的完全独立的进程服务。您应该看到curl命令立即输出“Hello，World！”，然后挂起60秒。您可以继续运行任意数量的curl命令（好吧，几乎可以运行任意数量），所有这些命令都会立即输出服务器的响应“Hello，World”，不会有任何明显的延迟。试试看。

了解fork（）最重要的一点是，调用fork一次，但它返回两次：一次在父进程中，一次在子进程中。分叉新进程时，返回给子进程的进程ID为0。当fork在父进程中返回时，它返回子进程的PID。

```bash
$ python webserver3c.py
```

那么，如果父进程关闭了同一个套接字，那么子进程为什么仍然能够从客户端套接字读取数据呢？内核使用描述符引用计数来决定是否关闭套接字。只有当其描述符引用计数变为0时，它才会关闭套接字。当服务器创建子进程时，子进程将获得父进程的文件描述符副本，内核将增加这些描述符的引用计数。在一个父进程和一个子进程的情况下，客户机套接字的描述符引用计数将为2，当上面代码中的父进程关闭客户机连接套接字时，它只会将其引用计数减为1，而不是减到足以导致内核关闭套接字的程度。子进程还关闭父进程listen_socket的副本，因为子进程不关心接受新的客户端连接，只关心处理来自已建立的客户端连接的请求。

Start the server with:

```bash
$ python webserver3d.py
```

那么为什么curl没有终止呢？原因是文件描述符重复。当子进程关闭客户机连接时，内核减少该客户机套接字的引用计数，计数变为1。服务器子进程已退出，但客户端套接字没有被内核关闭，因为该套接字描述符的引用计数不是0，因此，终止数据包（在TCP/IP术语中称为FIN）没有发送给客户端，客户端保持在线状态。还有一个问题。如果长时间运行的服务器没有关闭重复的文件描述符，那么它最终将耗尽可用的文件描述符(file descriptors )。

```bash
linux ❯ ulimit -a
-t: cpu time (seconds)              unlimited
-f: file size (blocks)              unlimited
-d: data seg size (kbytes)          unlimited
-s: stack size (kbytes)             8192
-c: core file size (blocks)         0
-m: resident set size (kbytes)      unlimited
-u: processes                       15342
-n: file descriptors                1024 (文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符)
-l: locked-in-memory size (kbytes)  65536
-v: address space (kbytes)          unlimited
-x: file locks                      unlimited
-i: pending signals                 15342
-q: bytes in POSIX msg queues       819200
-e: max nice                        0
-r: max rt priority                 0
-N 15:                              unlimited
```

## 如何解決僵尸进程
> 僵尸进程是一个已经终止的进程，但其父级尚未等待它，并且尚未收到其终止状态。当子进程在其父进程之前退出时，内核会将子进程变成僵尸，并存储有关该进程的一些信息，以供其父进程稍后检索。存储的信息通常是进程 ID、进程终止状态以及进程的资源使用情况。好的，僵尸是有目的的，但是如果您的服务器不处理这些僵尸，您的系统就会堵塞。
英文术语zombie process源自丧尸——不死之人，隐喻子进程已死但仍然没有被回收。与正常进程不同，kill命令对僵尸进程无效。孤儿进程不同于僵尸进程，其父进程已经死掉，但孤儿进程仍能正常执行，但并不会变为僵尸进程，因为被init（进程ID号为1）收养并wait其退出。

子进程死后，系统会发送SIGCHLD信号给父进程，父进程对其默认处理是忽略。如果想响应这个消息，父进程通常在信号事件处理程序中，使用wait系统调用来响应子进程的终止。

您需要修改您的服务器代码以等待僵尸获得其终止状态。您可以通过修改服务器以调用等待系统调用来执行此操作。不幸的是，这远非理想，因为如果您调用 wait 并且没有终止的子进程，则调用等待将阻止您的服务器，从而有效地阻止您的服务器处理新的客户端连接请求。还有其他选择吗？是的，有，其中之一是signal的组合
